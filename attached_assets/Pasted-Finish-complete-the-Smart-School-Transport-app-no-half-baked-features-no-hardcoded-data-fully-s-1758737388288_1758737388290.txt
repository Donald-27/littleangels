Finish & complete the Smart School Transport app (no half-baked features, no hardcoded data, fully seeded, redesigned UI & navigation, production-ready)

Goal:
Convert the existing Replit AI-generated app into a fully functional, production-ready Smart School Transport & Student Safety System. Do not leave any features partially implemented, hardcoded, mocked, or “for demo only.” Every button, tab, page, and setting must be wired to real back-end logic and data and must be testable immediately after deploy. Redesign the UI/UX completely for a fresh, unique, and colorful look (see UI requirements below). Seed realistic, comprehensive data for every section so all pages, graphs, and exports work from day one.

High-level constraints:

Stack must use the agreed free-tier components: React (Vite) + Tailwind for front-end, Supabase for DB/Auth/Storage/Functions, OpenStreetMap + Leaflet for maps, Firebase Cloud Messaging for push, and browser libraries for QR, PDF, and offline storage.

No values or IDs hardcoded in the frontend. All data loads from Supabase APIs or the local offline store (IndexedDB). Use environment vars for secrets.

All external integrations must be real where possible. For payment integrations (M-Pesa), provide a real integration if API credentials are provided; otherwise include a production-grade simulator plus clearly defined connectors/hooks so the real credentials can be dropped in later without code changes.

Implement Secure patterns: Supabase RLS to restrict parent visibility to their child(ren), use signed QR tokens (JWT/HMAC) for boarding, store service keys only in server env (Supabase Functions or Replit secrets).

Deliverables (complete):

Full repo structure (monorepo or single repo) with frontend/, supabase/ (schema & seed scripts), functions/ (serverless endpoints), and docs/.

SQL migrations and a seed/ script that creates: 3 branches, ~200 students, 1–2 guardians per student, 10 buses (across branches), 10 drivers, routes/stops, scheduled trips for a week, incidents, lost & found items, badge records, and sample FCM tokens. Also seed real-looking photos (use Unsplash placeholder images uploaded to Supabase Storage). Provide CSV exports for each seeded table (students.csv, guardians.csv, buses.csv, routes.csv).

Frontend UI rework (parent portal mobile-first, admin dashboard desktop-first, and driver PWA) with a new colorful, unique visual identity, Tailwind style tokens, and a small style guide (colors, type scale, spacing, components). Provide Light + Dark mode toggle.

Completed features: auth (role-aware), student & guardian profiles (edit + photo upload), QR generation & scanner (signed tokens, verify server-side), driver location updates + parent live tracking map, offline QR capture + IndexedDB sync, notifications via FCM (board/drop events, ETA alerts), calendar/events, incidents, lost & found, guardian substitution flow (OTP or admin approval), voice notes (record/playback/upload), receipts (jsPDF), CSV/Excel exports, eco metrics (CO₂ saved), badges & rewards.

Robust navigation redesign: explicit flows for each click — see Navigation & Page Flow section below — implement with React Router and state preservation.

Tests: at least E2E test scripts (Playwright or Cypress) that validate core flows: login as parent -> track bus -> receive simulated boarding notification; driver start trip -> scan QR (offline & online) -> sync logs; admin export attendance CSV.

Documentation: README.md with exact environment variables and steps to run locally and to deploy (Vercel / Replit / Netlify), plus a QA checklist and how to replace simulated bits (like M-Pesa) with real credentials.

Code quality: linting (eslint + prettier), type checking (TypeScript recommended), and clear folder organization; avoid any TODO markers for core flows.

UI / Design — redesign requirements (insist on this):

Create a brand-new, distinctive visual identity. Use multiple complementary colors (not one main color). Emphasize gradients, curved header shapes, glassmorphism cards, rounded corners, soft shadows, and playful icons. Include subtle motion (micro-interactions) for scan success, syncing, and toasts. Provide a small style token file with at least 6 color variables (primary, secondary, accent1, accent2, background, surface), two font scales, and spacing tokens.

Parent portal: mobile-first single-column layout, child card(s) at top with quick actions (Track Bus, Digital ID, Messages, Payments). “Track Bus” opens a full-screen map with ETA card. Use bright accent color strips per branch.

Admin portal: desktop-first with a left navigation and a main canvas. Top metrics cards, branch selector, live map widget, trips table, incidents list, and export controls. Include filter UI (date, branch, route). Charts should be attractive: attendance trend, on-time % (recharts or chart.js).

Driver PWA: minimalist bottom-nav with 3 core big buttons (Start/Stop Trip, Scan QR, Incident). Always show connection status (online/offline), unsynced scans count, and battery/GPS permission hints. Support camera permissions gracefully and keep scanner buffers small.

Polished components: modals, forms, toasts, confirmations, and a consistent iconography set. Add a playful “badge confetti” animation when awarding a badge.

Navigation & Page Flow (exact flows to implement):

Top-level routing: /login → selects role on first login or reads role from profile and routes to: /parent/dashboard, /admin/dashboard, or /driver/trips.

Parent:

/parent/dashboard — child tile(s), notifications feed, events calendar snippet, eco metric summary.

Click Track Bus → /parent/track/:tripId (full-screen map + ETA + stops list). Back returns to dashboard.

Click Digital ID → modal fullscreen showing scannable QR + copy link.

Click Payments → /parent/payments page with simulated M-Pesa flow + generate PDF receipt.

Click Messages → /parent/messages/:childId (voice note upload + messaging timeline).

Admin:

/admin/dashboard — metrics and active trips.

Click a trip on map → /admin/trips/:tripId (trip details, passenger list, boarding logs, incidents, replay map).

Click Reports → /admin/reports with filters and export buttons (CSV, PDF).

Settings → /admin/settings for school profile, color palette, branches, and RLS toggles.

Driver:

/driver/trips — list of assigned trips for today. Tap a trip → /driver/trips/:tripId with Start Trip button. Start trip opens live tracking and scanner.

Scanner uses camera and posts signed tokens to server; show real-time sync status and a retry button for failures.

Data & Seeding (explicit and comprehensive):

Create seed/seed.sql and CSVs with the following minimum data:

Branches: 3 (names, addresses, timezone Africa/Nairobi)

Students: 200 rows — columns: student_id, first_name, last_name, class, branch_id, photo_url, medical_notes

Guardians: at least 200 guardian records, with profile_id and verified phone/email — for ~50% of students include a second guardian. Include id_photo_url.

Buses: 10 buses with name, plate, capacity, branch_id.

Drivers: 10 driver profiles with photos and phone. Link one driver per bus.

Routes: 3–4 routes per branch; each route has stops JSON array with { name, lat, lng }.

Trips: scheduled trips for a 7-day range with start_time, end_time, bus_id, route_id.

Boarding logs: auto-generate logs for the last 30 days so analytics/charts show trends out-of-the-box. Include timestamps, lat/long, device_id, and event_type.

Incidents & Lost & Found: 10 items each with photos.

Badges & Eco Metrics: populate realistic badge counts and CO₂ calculations derived from trip data.

Provide a seed/README.md that explains how to re-run seeds and how to clear or re-seed in Supabase. All seeds should be idempotent.

QR design & Security:

Generate QR tokens server-side using a signed JWT or HMAC token containing { student_id, trip_id, exp }. QR expiry should be short (1–8 hours depending on use). The frontend must never encode raw student IDs without a signature.

Implement /api/scan and /api/scan/batch serverless endpoints (Supabase Function or Replit server) that verify tokens and write boarding_logs. For offline scans, driver PWA batches entries (unique UUID per scan) and scan/batch should dedupe and be idempotent.

Offline-first & sync behavior:

Use Service Worker + IndexedDB for caching assets and storing offline scans. Show unsynced count persistently to the driver. Implement a robust sync algorithm that backs off on failure and retries. Ensure no double-logs via idempotency keys.

Notifications & Real-time:

Store parent FCM tokens in profiles. On boarding/drop write, trigger a Supabase Function that calls FCM to send push notifications to the child’s guardians. Implement debouncing so parents don’t receive spam (e.g., group quick repeated location updates). For dev, include a simulated FCM token / dev UI to push test notifications.

Trip live-locations should broadcast via Supabase Realtime (or via a trip_locations table polled/subscribed by clients). Parents subscribe to the trip they care about.

Payments & Receipts:

Provide a simulated M-Pesa flow that behaves like the real API: mpesa request -> simulated success/failure -> update payment record -> generate PDF receipt with jsPDF. Include a PAYMENTS_README.md describing exactly how to swap simulated endpoints for real M-Pesa credentials.

Voice notes & file storage:

Implement client-side audio recorder (Web Audio / MediaRecorder), upload audio to Supabase Storage, and show playback UI in messages. Also allow driver/driver-admin to upload photos for incidents/lost items.

Analytics & Graphs:

Add these charts (auto-driven by seed data):

Daily attendance trend (last 30 days).

Trip punctuality (on-time % per route).

Eco: estimated CO₂ saved per branch and per month.

Charts must update when new data is created (i.e., not static images). Use recharts or chart.js with live queries to Supabase.

Testing & QA (explicit acceptance tests):
Provide E2E test scripts and a QA checklist. At minimum, tests must verify:

Parent login -> view child -> open Track Bus -> see map marker update over time (simulate location updates).

Driver login -> start trip -> scan QR (online) -> boarding_logs created -> parent receives push.

Driver offline scan -> reconnect -> batch sync -> verify logs created and no duplicates.

Admin export -> generate CSV -> file contains expected columns and recent data.

Payments -> simulate M-Pesa success -> receipt PDF generated.

Guardian substitution -> submit substitute guardian -> driver sees substitute in pickup list with ID photo.

Developer ergonomics & docs:

Provide ENV.example listing every required var and where to get it: SUPABASE_URL, SUPABASE_ANON_KEY, SUPABASE_SERVICE_ROLE_KEY, QR_SECRET, FCM_SERVER_KEY, MPESA_CONSUMER_KEY/MPESA_CONSUMER_SECRET (optional), and REPLIT_SECRET_* if using Replit.

README.md must include one-command local start (or a small script) and deployment instructions to Vercel/Replit. Include a troubleshooting section for permissions (camera, microphone, notifications).

Optional but strongly recommended improvements (apply if you can):

Implement simple role-based admin UI to change the app color palette and upload school logo and assets (persist in Supabase Storage). The new colors update the theme tokens live.

Add lightweight accessibility checks and fix major a11y issues (contrast, ARIA attributes, keyboard navigation).

Provide a small demo script endpoint that simulates a driver sending live locations so QA can watch the parent map update without needing a driver phone.

Final acceptance:

The app is only “done” when the full repo is produced with all features above wired to real backend calls, seeded data flows into UI and charts, core E2E tests pass, and the README.md provides the steps to reproduce locally and to deploy to production. No placeholder text like “TODO”, “FAKE”, or “MOCK” should remain in the core flows.

Deliver the result as:

The completed repo files and code (or a tarball link), plus a step-by-step DEPLOY.md for Replit and Vercel, plus a QA_CHECKLIST.md. Also include the seed CSVs and seed.sql.

If anything cannot be fully implemented because of external credentials (FCM server key, M-Pesa keys, 3rd-party paid APIs), do the following:

Provide a production-grade simulator that behaves exactly like the real service and can be swapped out by setting environment variables.

Include detailed HOWTO steps showing exactly where to paste real credentials and how to test them.

Start by:

Scanning the current repo for all hardcoded values and replace them with dynamic DB queries or environment variables.

Adding the SQL schema & idempotent seed scripts and running them.

Reworking the UI per the design spec in the prompt and implementing the new navigation flows.

Implementing the serverless functions for QR signing, scan verification, FCM notifications, and payment hooks.

Writing E2E tests and a QA Checklist.

Finish only when all the Deliverables and Acceptance Tests above are met and you can show a short demo video or step-by-step screenshots proving the core flows work (login, track, scan, sync, export, payments simulation).